local Colyseus = require "colyseus.client"

-- SERVER VARS
local server_address = "localhost"
local server_port = "3553"

-- Vars
local client
local max_clients = 4
local room
local delay = 0
local delay_time = 0

-- player score
local score = 0
local score = score -- What does this do?

local time_os = os.clock()
local timetaken_os = 0


-- scores given out
local firstplace = 10
local secondplace = 5
local badreaction = 10

local goodbad = 0
local goodbad = goodbad -- What does this do?

local centerposition;

local goodisactive = false
local badisactive = true

local badoldpos
local goodoldpos

local pickactive

function init(self)
	msg.post(".", "acquire_input_focus")

	client = Colyseus.new("ws://" .. server_address .. ":" .. server_port, false) -- false: not to connect immediately

	client:join_or_create("reactiongame", function(err, room_instance)
		if (err ~= nil) then
			print("JOIN ERROR: " .. err)
			return
		end

		-- assign room instance to global "room" variable
		room = room_instance

		
		-- listen to room state change from the room handler
		-- user this method to syncronize the room state from
		print("PLAYERS:")
		pprint(room.state.players)
		pprint(room.state.messages)
		print("successfully joined '" .. room.name .. "'")

		-- room.state.messages['on_add'] = function(msg, sessionId)
		-- 	print("message arrived", msg.message)
		-- end

		room.state.players.on_add = function(player, sessionId)
			print("new player")
			pprint(player)
		end

		room.state.on_change = function(changes)
			print("state changes")
			pickactive = room.state.mode
			Setactives()
			Setpositions()
		end

		room:on_message("data", function(message)
			print("colyseus-defold: 'data' message received =>")
			pprint(message)
		end)

		room:on("leave", function()
			print("left '" .. room.name .. "'")
		end)
	end);
	
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
	centerposition = go.get_position("wait")
	goodoldpos = go.get_position("good")
	badoldpos = go.get_position("bad")

	msg.post("/bad#Sprite", "disable")
	msg.post("/good#Sprite", "disable")
	--msg.post("/wait#Sprite", "disable")
	
end

function update(self, dt)
	client:loop()
	-- time = time + dt using os.clock() instead of dt
	-- Whatsactive()
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if os.clock() > delay_time + delay then
			Settimetaken()
			Plusscore()
			-- print(badisactive)
		end
	end
end

function Settimetaken()
	-- timetaken = time
	timetaken_os = math.floor(1000*(os.clock() - time_os))
	time_os = os.clock()

	if room~=nil then
		if room.state.mode == 1 then
		room:send("time", {time_taken = timetaken_os})
		elseif room.state.mode == 2 then
			delay = 2
		end
		delay = delay + 1
		delay_time = os.clock()
	else
		print("ROOM ERROR: Room is nil")
	end
	-- print(timetaken)
	print(timetaken_os)
end

function Plusscore()
	-- add real score
	score = score + 1
	print(score)
end

function Setactives ()
	if pickactive == 1 then
		goodisactive = true
		badisactive = false
		print("good is active")
		msg.post("good#Sprite", "enable")
		time_os = os.clock()
	end

	if pickactive == 2 then
		badisactive = true
		goodisactive = false
		print("bad is active")
		msg.post("bad#Sprite", "enable")
	end

	if pickactive == 0 then
		badisactive = false
		goodisactive = false
		print("Neutral is active")
		msg.post("wait#Sprite", "enable")
	end

	-- time = 0
end

--function Setpositions()
--	if goodisactive == true then
--		go.set_position(centerposition,"good")
--		go.set_position(badoldpos,"bad")
--	else
--		go.set_position(goodoldpos,"good")
--	end
--	if badisactive == true then
--		go.set_position(centerposition,"bad")
--		go.set_position(goodoldpos,"good")
--	else
--		go.set_position(badoldpos,"bad")
--	end
--end